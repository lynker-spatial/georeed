#' Create GeoParquet file metadata
#' @param version \emph{\code{character(1)}}\cr
#' The version identifier for the GeoParquet specification.
#' @param primary_column \emph{\code{character(1)}}\cr
#' The name of the "primary" geometry column.
#' In cases where a GeoParquet file contains multiple geometry columns,
#' the primary geometry may be used by default in geospatial operations.
#' @param columns \emph{\code{list}}\cr
#' Metadata about geometry columns.
#' Each key is the name of a geometry column in the table.
#' @details Specification from https://geoparquet.org/releases/v1.0.0/
#' @seealso geoparquet_column_metadata
#' @keywords internal
#' @return `list`
geoparquet_file_metadata <- function(version, primary_column, columns) {
  as.list(environment())
}

#' Create GeoParquet column metadata
#' @param encoding \emph{\code{character(1)}}\cr
#' Name of the geometry encoding format.
#' Currently only "WKB" is supported.
#' @param geometry_types \emph{\code{character(N)}}\cr
#' The geometry types of all geometries,
#' or an empty array if they are not known.
#' @param ... Additional named arguments included in the returned list.
#' @seealso geoparquet_file_metadata
#' @keywords internal
#' @return `list`
geoparquet_column_metadata <- function(encoding, geometry_types, ...) {
  c(as.list(environment()), list(...))
}


#' Create GeoParquet metadata
#' @param .data \emph{\code{sf}}\cr
#' Data to base metadata from.
#' @param ... Named arguments for extra metadata added
#' to the parquet file, see details.
#' @param encoding \emph{\code{character(1)}}\cr
#' Type of encoding that the geometry will be in.
#' Must be either *WKB* or one of:
#' \itemize{
#'   \item *point*
#'   \item *linestring*
#'   \item *polygon*
#'   \item *multipoint*
#'   \item *multilinestring*
#'   \item *multipolygon*
#' }
#'
#' @param covering \emph{\code{logical(1)}}\cr
#' Experimental metadata option to include
#' geometry envelopes as a new parquet column.
#' If `TRUE`, assumes the bbox column was generated by
#' this package.
#'
#' @details
#' Extra named arguments passed to this function will be passed
#' to a `list` call for the metadata added to a GeoParquet file.
#' To specify additional custom metadata, each named argument
#' must be convertible to JSON.
#'
#' @return `list` of the named arguments and the values coerced to JSON strings.
#' @keywords internal
geoparquet_metadata <- function(.data, ..., encoding = "WKB", covering = FALSE) {
  if (!inherits(.data, "sf")) {
    stop("`.data` must be an `sf` object.")
  }

  # Create column metadata
  geom_columns <- geometry_columns(.data)
  column_meta  <- lapply(geom_columns, \(col) {
    # title case geometry per geoparquet spec
    .type <- unique(switch(
      as.character(sf::st_geometry_type(.data[[col]], by_geometry = TRUE)),
      POINT = "Point",
      LINESTRING = "LineString",
      POLYGON = "Polygon",
      MULTIPOINT = "MultiPoint",
      MULTILINESTRING = "MultiLineString",
      MULTIPOLYGON = "MultiPolygon",
      GEOMETRYCOLLECTION = "GeometryCollection"
    ))

    if (encoding == "arrow") {
      if (length(.type) > 1) {
        stop(
          "GeoArrow encoding only supports homogenous geometry types, but geometry contains `",
          paste0(.type, collapse = "/"),
          "`.",
          call. = FALSE)
      }

      encoding <- tolower(.type)

      if (!encoding %in% c(
        "point", "linestring", "polygon",
        "multipoint", "multilinestring", "multipolygon"
      )) {
        stop(
          "GeoArrow encoding for type `", encoding, "` not supported.",
          call. = FALSE
        )
      }
    } else {
      encoding <- toupper(encoding)
    }

    .call_args <- list(
      encoding = encoding,
      geometry_types = .type,
      crs = sf::st_crs(.data[[col]])$Wkt,
      bbox = as.numeric(sf::st_bbox(.data[[col]]))
    )

    if (.type %in% c("Polygon", "MultiPolygon")) {
      .call_args$orientation <- "counterclockwise"
    }

    if (sf::st_is_longlat(.data)) {
      .call_args$edges <- "spherical"
    } else {
      .call_args$edges <- "planar"
    }

    if (covering) {
      .call_args$covering <- list(
        bbox = list(
          xmin = c("bbox", "xmin"),
          ymin = c("bbox", "ymin"),
          xmax = c("bbox", "xmax"),
          ymax = c("bbox", "ymax")
        )
      )
    }

    do.call(geoparquet_column_metadata, .call_args)
  })

  names(column_meta) <- geom_columns


  lapply(list(
    geo = geoparquet_file_metadata(
      version = "1.0.0",
      primary_column = attr(.data, "sf_column", exact = TRUE),
      columns = column_meta
    ),
    ...
  ), jsonlite::toJSON, auto_unbox = TRUE)
}

